!(function (e) { if (typeof exports === 'object' && typeof module !== 'undefined')module.exports = e(); else if (typeof define === 'function' && define.amd)define([], e); else { var t; t = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this, t.getusermedia = e() } }(function () {
  return (function e (t, n, r) { function i (o, s) { if (!n[o]) { if (!t[o]) { var c = typeof require === 'function' && require; if (!s && c) return c(o, !0); if (a) return a(o, !0); var d = new Error("Cannot find module '" + o + "'"); throw d.code = 'MODULE_NOT_FOUND', d } var p = n[o] = {exports: {}}; t[o][0].call(p.exports, function (e) { var n = t[o][1][e]; return i(n ? n : e) }, p, p.exports, e, t, n, r) } return n[o].exports } for (var a = typeof require === 'function' && require, o = 0; o < r.length; o++)i(r[o]); return i }({1: [function (e, t, n) { e('webrtc-adapter'); t.exports = function (e, t) { var n, r = arguments.length === 2, i = {video: !0, audio: !0}, a = 'PermissionDeniedError', o = 'PERMISSION_DENIED', s = 'ConstraintNotSatisfiedError'; return r || (t = e, e = i), typeof navigator !== 'undefined' && navigator.getUserMedia ? e.audio || e.video ? void navigator.mediaDevices.getUserMedia(e).then(function (e) { t(null, e) }).catch(function (e) { var n; typeof e === 'string' ? (n = new Error('MediaStreamError'), e === a || e === o ? n.name = a : n.name = s) : (n = e, n.name || (n[a] ? e.name = a : e.name = s)), t(n) }) : (n = new Error('MediaStreamError'), n.name = 'NoMediaRequestedError', setTimeout(function () { t(n) }, 0)) : (n = new Error('MediaStreamError'), n.name = 'NotSupportedError', setTimeout(function () { t(n) }, 0)) } }, {'webrtc-adapter': 3}], 2: [function (e, t, n) { 'use strict'; var r = {}; r.generateIdentifier = function () { return Math.random().toString(36).substr(2, 10) }, r.localCName = r.generateIdentifier(), r.splitLines = function (e) { return e.trim().split('\n').map(function (e) { return e.trim() }) }, r.splitSections = function (e) { var t = e.split('\nm='); return t.map(function (e, t) { return (t > 0 ? 'm=' + e : e).trim() + '\r\n' }) }, r.matchPrefix = function (e, t) { return r.splitLines(e).filter(function (e) { return e.indexOf(t) === 0 }) }, r.parseCandidate = function (e) { var t; t = e.indexOf('a=candidate:') === 0 ? e.substring(12).split(' ') : e.substring(10).split(' '); for (var n = {foundation: t[0], component: t[1], protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], port: parseInt(t[5], 10), type: t[7]}, r = 8; r < t.length; r += 2) switch (t[r]) { case 'raddr':n.relatedAddress = t[r + 1]; break; case 'rport':n.relatedPort = parseInt(t[r + 1], 10); break; case 'tcptype':n.tcpType = t[r + 1] } return n }, r.writeCandidate = function (e) { var t = []; t.push(e.foundation), t.push(e.component), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.ip), t.push(e.port); var n = e.type; return t.push('typ'), t.push(n), n !== 'host' && e.relatedAddress && e.relatedPort && (t.push('raddr'), t.push(e.relatedAddress), t.push('rport'), t.push(e.relatedPort)), e.tcpType && e.protocol.toLowerCase() === 'tcp' && (t.push('tcptype'), t.push(e.tcpType)), 'candidate:' + t.join(' ') }, r.parseRtpMap = function (e) { var t = e.substr(9).split(' '), n = {payloadType: parseInt(t.shift(), 10)}; return t = t[0].split('/'), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.numChannels = t.length === 3 ? parseInt(t[2], 10) : 1, n }, r.writeRtpMap = function (e) { var t = e.payloadType; return void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType), 'a=rtpmap:' + t + ' ' + e.name + '/' + e.clockRate + (e.numChannels !== 1 ? '/' + e.numChannels : '') + '\r\n' }, r.parseExtmap = function (e) { var t = e.substr(9).split(' '); return {id: parseInt(t[0], 10), uri: t[1]} }, r.writeExtmap = function (e) { return 'a=extmap:' + (e.id || e.preferredId) + ' ' + e.uri + '\r\n' }, r.parseFmtp = function (e) { for (var t, n = {}, r = e.substr(e.indexOf(' ') + 1).split(';'), i = 0; i < r.length; i++)t = r[i].trim().split('='), n[t[0].trim()] = t[1]; return n }, r.writeFmtp = function (e) { var t = '', n = e.payloadType; if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) { var r = []; Object.keys(e.parameters).forEach(function (t) { r.push(t + '=' + e.parameters[t]) }), t += 'a=fmtp:' + n + ' ' + r.join(';') + '\r\n' } return t }, r.parseRtcpFb = function (e) { var t = e.substr(e.indexOf(' ') + 1).split(' '); return {type: t.shift(), parameter: t.join(' ')} }, r.writeRtcpFb = function (e) { var t = '', n = e.payloadType; return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(function (e) { t += 'a=rtcp-fb:' + n + ' ' + e.type + (e.parameter && e.parameter.length ? ' ' + e.parameter : '') + '\r\n' }), t }, r.parseSsrcMedia = function (e) { var t = e.indexOf(' '), n = {ssrc: parseInt(e.substr(7, t - 7), 10)}, r = e.indexOf(':', t); return r > -1 ? (n.attribute = e.substr(t + 1, r - t - 1), n.value = e.substr(r + 1)) : n.attribute = e.substr(t + 1), n }, r.getDtlsParameters = function (e, t) { var n = r.splitLines(e); n = n.concat(r.splitLines(t)); var i = n.filter(function (e) { return e.indexOf('a=fingerprint:') === 0 })[0].substr(14), a = {role: 'auto', fingerprints: [{algorithm: i.split(' ')[0].toLowerCase(), value: i.split(' ')[1]}]}; return a }, r.writeDtlsParameters = function (e, t) { var n = 'a=setup:' + t + '\r\n'; return e.fingerprints.forEach(function (e) { n += 'a=fingerprint:' + e.algorithm + ' ' + e.value + '\r\n' }), n }, r.getIceParameters = function (e, t) { var n = r.splitLines(e); n = n.concat(r.splitLines(t)); var i = {usernameFragment: n.filter(function (e) { return e.indexOf('a=ice-ufrag:') === 0 })[0].substr(12), password: n.filter(function (e) { return e.indexOf('a=ice-pwd:') === 0 })[0].substr(10)}; return i }, r.writeIceParameters = function (e) { return 'a=ice-ufrag:' + e.usernameFragment + '\r\na=ice-pwd:' + e.password + '\r\n' }, r.parseRtpParameters = function (e) { for (var t = {codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: []}, n = r.splitLines(e), i = n[0].split(' '), a = 3; a < i.length; a++) { var o = i[a], s = r.matchPrefix(e, 'a=rtpmap:' + o + ' ')[0]; if (s) { var c = r.parseRtpMap(s), d = r.matchPrefix(e, 'a=fmtp:' + o + ' '); switch (c.parameters = d.length ? r.parseFmtp(d[0]) : {}, c.rtcpFeedback = r.matchPrefix(e, 'a=rtcp-fb:' + o + ' ').map(r.parseRtcpFb), t.codecs.push(c), c.name.toUpperCase()) { case 'RED':case 'ULPFEC':t.fecMechanisms.push(c.name.toUpperCase()) } } } return r.matchPrefix(e, 'a=extmap:').forEach(function (e) { t.headerExtensions.push(r.parseExtmap(e)) }), t }, r.writeRtpDescription = function (e, t) { var n = ''; n += 'm=' + e + ' ', n += t.codecs.length > 0 ? '9' : '0', n += ' UDP/TLS/RTP/SAVPF ', n += t.codecs.map(function (e) { return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType }).join(' ') + '\r\n', n += 'c=IN IP4 0.0.0.0\r\n', n += 'a=rtcp:9 IN IP4 0.0.0.0\r\n', t.codecs.forEach(function (e) { n += r.writeRtpMap(e), n += r.writeFmtp(e), n += r.writeRtcpFb(e) }); var i = 0; return t.codecs.forEach(function (e) { e.maxptime > i && (i = e.maxptime) }), i > 0 && (n += 'a=maxptime:' + i + '\r\n'), n += 'a=rtcp-mux\r\n', t.headerExtensions.forEach(function (e) { n += r.writeExtmap(e) }), n }, r.parseRtpEncodingParameters = function (e) { var t, n = [], i = r.parseRtpParameters(e), a = i.fecMechanisms.indexOf('RED') !== -1, o = i.fecMechanisms.indexOf('ULPFEC') !== -1, s = r.matchPrefix(e, 'a=ssrc:').map(function (e) { return r.parseSsrcMedia(e) }).filter(function (e) { return e.attribute === 'cname' }), c = s.length > 0 && s[0].ssrc, d = r.matchPrefix(e, 'a=ssrc-group:FID').map(function (e) { var t = e.split(' '); return t.shift(), t.map(function (e) { return parseInt(e, 10) }) }); d.length > 0 && d[0].length > 1 && d[0][0] === c && (t = d[0][1]), i.codecs.forEach(function (e) { if (e.name.toUpperCase() === 'RTX' && e.parameters.apt) { var r = {ssrc: c, codecPayloadType: parseInt(e.parameters.apt, 10), rtx: {ssrc: t}}; n.push(r), a && (r = JSON.parse(JSON.stringify(r)), r.fec = {ssrc: t, mechanism: o ? 'red+ulpfec' : 'red'}, n.push(r)) } }), n.length === 0 && c && n.push({ssrc: c}); var p = r.matchPrefix(e, 'b='); return p.length && (p[0].indexOf('b=TIAS:') === 0 ? p = parseInt(p[0].substr(7), 10) : p[0].indexOf('b=AS:') === 0 && (p = parseInt(p[0].substr(5), 10)), n.forEach(function (e) { e.maxBitrate = p })), n }, r.parseRtcpParameters = function (e) { var t = {}, n = r.matchPrefix(e, 'a=ssrc:').map(function (e) { return r.parseSsrcMedia(e) }).filter(function (e) { return e.attribute === 'cname' })[0]; n && (t.cname = n.value, t.ssrc = n.ssrc); var i = r.matchPrefix(e, 'a=rtcp-rsize'); t.reducedSize = i.length > 0, t.compound = i.length === 0; var a = r.matchPrefix(e, 'a=rtcp-mux'); return t.mux = a.length > 0, t }, r.parseMsid = function (e) { var t, n = r.matchPrefix(e, 'a=msid:'); if (n.length === 1) return t = n[0].substr(7).split(' '), {stream: t[0], track: t[1]}; var i = r.matchPrefix(e, 'a=ssrc:').map(function (e) { return r.parseSsrcMedia(e) }).filter(function (e) { return e.attribute === 'msid' }); return i.length > 0 ? (t = i[0].value.split(' '), {stream: t[0], track: t[1]}) : void 0 }, r.writeSessionBoilerplate = function () { return 'v=0\r\no=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n' }, r.writeMediaSection = function (e, t, n, i) { var a = r.writeRtpDescription(e.kind, t); if (a += r.writeIceParameters(e.iceGatherer.getLocalParameters()), a += r.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), n === 'offer' ? 'actpass' : 'active'), a += 'a=mid:' + e.mid + '\r\n', a += e.rtpSender && e.rtpReceiver ? 'a=sendrecv\r\n' : e.rtpSender ? 'a=sendonly\r\n' : e.rtpReceiver ? 'a=recvonly\r\n' : 'a=inactive\r\n', e.rtpSender) { var o = 'msid:' + i.id + ' ' + e.rtpSender.track.id + '\r\n'; a += 'a=' + o, a += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' ' + o, e.sendEncodingParameters[0].rtx && (a += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' ' + o, a += 'a=ssrc-group:FID ' + e.sendEncodingParameters[0].ssrc + ' ' + e.sendEncodingParameters[0].rtx.ssrc + '\r\n') } return a += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' cname:' + r.localCName + '\r\n', e.rtpSender && e.sendEncodingParameters[0].rtx && (a += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' cname:' + r.localCName + '\r\n'), a }, r.getDirection = function (e, t) { for (var n = r.splitLines(e), i = 0; i < n.length; i++) switch (n[i]) { case 'a=sendrecv':case 'a=sendonly':case 'a=recvonly':case 'a=inactive':return n[i].substr(2) } return t ? r.getDirection(t) : 'sendrecv' }, r.getKind = function (e) { var t = r.splitLines(e), n = t[0].split(' '); return n[0].substr(2) }, r.isRejected = function (e) { return e.split(' ', 2)[1] === '0' }, t.exports = r }, {}], 3: [function (e, t, n) { 'use strict'; !(function () { var n = e('./utils').log, r = e('./utils').browserDetails; t.exports.browserDetails = r, t.exports.extractVersion = e('./utils').extractVersion, t.exports.disableLog = e('./utils').disableLog; var i = e('./chrome/chrome_shim') || null, a = e('./edge/edge_shim') || null, o = e('./firefox/firefox_shim') || null, s = e('./safari/safari_shim') || null; switch (r.browser) { case 'opera':case 'chrome':if (!i || !i.shimPeerConnection) return void n('Chrome shim is not included in this adapter release.'); n('adapter.js shimming chrome.'), t.exports.browserShim = i, i.shimGetUserMedia(), i.shimMediaStream(), i.shimSourceObject(), i.shimPeerConnection(), i.shimOnTrack(); break; case 'firefox':if (!o || !o.shimPeerConnection) return void n('Firefox shim is not included in this adapter release.'); n('adapter.js shimming firefox.'), t.exports.browserShim = o, o.shimGetUserMedia(), o.shimSourceObject(), o.shimPeerConnection(), o.shimOnTrack(); break; case 'edge':if (!a || !a.shimPeerConnection) return void n('MS edge shim is not included in this adapter release.'); n('adapter.js shimming edge.'), t.exports.browserShim = a, a.shimGetUserMedia(), a.shimPeerConnection(); break; case 'safari':if (!s) return void n('Safari shim is not included in this adapter release.'); n('adapter.js shimming safari.'), t.exports.browserShim = s, s.shimGetUserMedia(); break; default:n('Unsupported browser!') } }()) }, {'./chrome/chrome_shim': 4, './edge/edge_shim': 6, './firefox/firefox_shim': 8, './safari/safari_shim': 10, './utils': 11}], 4: [function (e, t, n) { 'use strict'; var r = e('../utils.js').log, i = e('../utils.js').browserDetails, a = {shimMediaStream: function () { window.MediaStream = window.MediaStream || window.webkitMediaStream }, shimOnTrack: function () { typeof window !== 'object' || !window.RTCPeerConnection || 'ontrack' in window.RTCPeerConnection.prototype || Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {get: function () { return this._ontrack }, set: function (e) { var t = this; this._ontrack && (this.removeEventListener('track', this._ontrack), this.removeEventListener('addstream', this._ontrackpoly)), this.addEventListener('track', this._ontrack = e), this.addEventListener('addstream', this._ontrackpoly = function (e) { e.stream.addEventListener('addtrack', function (n) { var r = new Event('track'); r.track = n.track, r.receiver = {track: n.track}, r.streams = [e.stream], t.dispatchEvent(r) }), e.stream.getTracks().forEach(function (t) { var n = new Event('track'); n.track = t, n.receiver = {track: t}, n.streams = [e.stream], this.dispatchEvent(n) }.bind(this)) }.bind(this)) }}) }, shimSourceObject: function () { typeof window === 'object' && (!window.HTMLMediaElement || 'srcObject' in window.HTMLMediaElement.prototype || Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {get: function () { return this._srcObject }, set: function (e) { var t = this; return this._srcObject = e, this.src && URL.revokeObjectURL(this.src), e ? (this.src = URL.createObjectURL(e), e.addEventListener('addtrack', function () { t.src && URL.revokeObjectURL(t.src), t.src = URL.createObjectURL(e) }), void e.addEventListener('removetrack', function () { t.src && URL.revokeObjectURL(t.src), t.src = URL.createObjectURL(e) })) : void (this.src = '') }})) }, shimPeerConnection: function () { window.RTCPeerConnection = function (e, t) { r('PeerConnection'), e && e.iceTransportPolicy && (e.iceTransports = e.iceTransportPolicy); var n = new webkitRTCPeerConnection(e, t), i = n.getStats.bind(n); return n.getStats = function (e, t, n) { var r = this, a = arguments; if (arguments.length > 0 && typeof e === 'function') return i(e, t); var o = function (e) { var t = {}, n = e.result(); return n.forEach(function (e) { var n = {id: e.id, timestamp: e.timestamp, type: e.type}; e.names().forEach(function (t) { n[t] = e.stat(t) }), t[n.id] = n }), t }, s = function (e, t) { var n = new Map(Object.keys(e).map(function (t) { return [t, e[t]] })); return t = t || e, Object.keys(t).forEach(function (e) { n[e] = t[e] }), n }; if (arguments.length >= 2) { var c = function (e) { a[1](s(o(e))) }; return i.apply(this, [c, arguments[0]]) } return new Promise(function (t, n) { a.length === 1 && typeof e === 'object' ? i.apply(r, [function (e) { t(s(o(e))) }, n]) : i.apply(r, [function (e) { t(s(o(e), e.result())) }, n]) }).then(t, n) }, n }, window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype, webkitRTCPeerConnection.generateCertificate && Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {get: function () { return webkitRTCPeerConnection.generateCertificate }}), ['createOffer', 'createAnswer'].forEach(function (e) { var t = webkitRTCPeerConnection.prototype[e]; webkitRTCPeerConnection.prototype[e] = function () { var e = this; if (arguments.length < 1 || arguments.length === 1 && typeof arguments[0] === 'object') { var n = arguments.length === 1 ? arguments[0] : void 0; return new Promise(function (r, i) { t.apply(e, [r, i, n]) }) } return t.apply(this, arguments) } }), i.version < 51 && ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (e) { var t = webkitRTCPeerConnection.prototype[e]; webkitRTCPeerConnection.prototype[e] = function () { var e = arguments, n = this, r = new Promise(function (r, i) { t.apply(n, [e[0], r, i]) }); return e.length < 2 ? r : r.then(function () { e[1].apply(null, []) }, function (t) { e.length >= 3 && e[2].apply(null, [t]) }) } }), ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (e) { var t = webkitRTCPeerConnection.prototype[e]; webkitRTCPeerConnection.prototype[e] = function () { return arguments[0] = new (e === 'addIceCandidate' ? RTCIceCandidate : RTCSessionDescription)(arguments[0]), t.apply(this, arguments) } }); var e = RTCPeerConnection.prototype.addIceCandidate; RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? e.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) } }}; t.exports = {shimMediaStream: a.shimMediaStream, shimOnTrack: a.shimOnTrack, shimSourceObject: a.shimSourceObject, shimPeerConnection: a.shimPeerConnection, shimGetUserMedia: e('./getusermedia')} }, {'../utils.js': 11, './getusermedia': 5}], 5: [function (e, t, n) { 'use strict'; var r = e('../utils.js').log; t.exports = function () { var e = function (e) { if (typeof e !== 'object' || e.mandatory || e.optional) return e; var t = {}; return Object.keys(e).forEach(function (n) { if (n !== 'require' && n !== 'advanced' && n !== 'mediaSource') { var r = typeof e[n] === 'object' ? e[n] : {ideal: e[n]}; void 0 !== r.exact && typeof r.exact === 'number' && (r.min = r.max = r.exact); var i = function (e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : t === 'deviceId' ? 'sourceId' : t }; if (void 0 !== r.ideal) { t.optional = t.optional || []; var a = {}; typeof r.ideal === 'number' ? (a[i('min', n)] = r.ideal, t.optional.push(a), a = {}, a[i('max', n)] = r.ideal, t.optional.push(a)) : (a[i('', n)] = r.ideal, t.optional.push(a)) } void 0 !== r.exact && typeof r.exact !== 'number' ? (t.mandatory = t.mandatory || {}, t.mandatory[i('', n)] = r.exact) : ['min', 'max'].forEach(function (e) { void 0 !== r[e] && (t.mandatory = t.mandatory || {}, t.mandatory[i(e, n)] = r[e]) }) } }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t }, t = function (t, n) { if (t = JSON.parse(JSON.stringify(t)), t && t.audio && (t.audio = e(t.audio)), t && typeof t.video === 'object') { var i = t.video.facingMode; if (i = i && (typeof i === 'object' ? i : {ideal: i}), i && (i.exact === 'user' || i.exact === 'environment' || i.ideal === 'user' || i.ideal === 'environment') && (!navigator.mediaDevices.getSupportedConstraints || !navigator.mediaDevices.getSupportedConstraints().facingMode) && (delete t.video.facingMode, i.exact === 'environment' || i.ideal === 'environment')) return navigator.mediaDevices.enumerateDevices().then(function (a) { a = a.filter(function (e) { return e.kind === 'videoinput' }); var o = a.find(function (e) { return e.label.toLowerCase().indexOf('back') !== -1 }) || a.length && a[a.length - 1]; return o && (t.video.deviceId = i.exact ? {exact: o.deviceId} : {ideal: o.deviceId}), t.video = e(t.video), r('chrome: ' + JSON.stringify(t)), n(t) }); t.video = e(t.video) } return r('chrome: ' + JSON.stringify(t)), n(t) }, n = function (e) { return {name: {PermissionDeniedError: 'NotAllowedError', ConstraintNotSatisfiedError: 'OverconstrainedError'}[e.name] || e.name, message: e.message, constraint: e.constraintName, toString: function () { return this.name + (this.message && ': ') + this.message }} }, i = function (e, r, i) { t(e, function (e) { navigator.webkitGetUserMedia(e, r, function (e) { i(n(e)) }) }) }; navigator.getUserMedia = i; var a = function (e) { return new Promise(function (t, n) { navigator.getUserMedia(e, t, n) }) }; if (navigator.mediaDevices || (navigator.mediaDevices = {getUserMedia: a, enumerateDevices: function () { return new Promise(function (e) { var t = {audio: 'audioinput', video: 'videoinput'}; return MediaStreamTrack.getSources(function (n) { e(n.map(function (e) { return {label: e.label, kind: t[e.kind], deviceId: e.id, groupId: ''} })) }) }) }}), navigator.mediaDevices.getUserMedia) { var o = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function (e) { return t(e, function (e) { return o(e).then(function (t) { if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach(function (e) { e.stop() }), new DOMException('', 'NotFoundError'); return t }, function (e) { return Promise.reject(n(e)) }) }) } } else navigator.mediaDevices.getUserMedia = function (e) { return a(e) }; typeof navigator.mediaDevices.addEventListener === 'undefined' && (navigator.mediaDevices.addEventListener = function () { r('Dummy mediaDevices.addEventListener called.') }), typeof navigator.mediaDevices.removeEventListener === 'undefined' && (navigator.mediaDevices.removeEventListener = function () { r('Dummy mediaDevices.removeEventListener called.') }) } }, {'../utils.js': 11}], 6: [function (e, t, n) {
    'use strict'; var r = e('sdp'), i = e('../utils').browserDetails, a = {shimPeerConnection: function () {
        if (window.RTCIceGatherer) { window.RTCIceCandidate || (window.RTCIceCandidate = function (e) { return e }), window.RTCSessionDescription || (window.RTCSessionDescription = function (e) { return e }); var e = Object.getOwnPropertyDescriptor(MediaStreamTrack.prototype, 'enabled'); Object.defineProperty(MediaStreamTrack.prototype, 'enabled', {set: function (t) { e.set.call(this, t); var n = new Event('enabled'); n.enabled = t, this.dispatchEvent(n) }}) }window.RTCPeerConnection = function (e) { var t = this, n = document.createDocumentFragment(); if (['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(function (e) { t[e] = n[e].bind(n) }), this.onicecandidate = null, this.onaddstream = null, this.ontrack = null, this.onremovestream = null, this.onsignalingstatechange = null, this.oniceconnectionstatechange = null, this.onnegotiationneeded = null, this.ondatachannel = null, this.localStreams = [], this.remoteStreams = [], this.getLocalStreams = function () { return t.localStreams }, this.getRemoteStreams = function () { return t.remoteStreams }, this.localDescription = new RTCSessionDescription({type: '', sdp: ''}), this.remoteDescription = new RTCSessionDescription({type: '', sdp: ''}), this.signalingState = 'stable', this.iceConnectionState = 'new', this.iceGatheringState = 'new', this.iceOptions = {gatherPolicy: 'all', iceServers: []}, e && e.iceTransportPolicy) switch (e.iceTransportPolicy) { case 'all':case 'relay':this.iceOptions.gatherPolicy = e.iceTransportPolicy; break; case 'none':throw new TypeError('iceTransportPolicy "none" not supported') } if (this.usingBundle = e && e.bundlePolicy === 'max-bundle', e && e.iceServers) { var r = JSON.parse(JSON.stringify(e.iceServers)); this.iceOptions.iceServers = r.filter(function (e) { if (e && e.urls) { var t = e.urls; return typeof t === 'string' && (t = [t]), t = t.filter(function (e) { return e.indexOf('turn:') === 0 && e.indexOf('transport=udp') !== -1 && e.indexOf('turn:[') === -1 || e.indexOf('stun:') === 0 && i.version >= 14393 })[0], !!t } return !1 }) } this._config = e, this.transceivers = [], this._localIceCandidatesBuffer = [] }, window.RTCPeerConnection.prototype._emitBufferedCandidates = function () { var e = this, t = r.splitSections(e.localDescription.sdp); this._localIceCandidatesBuffer.forEach(function (n) { var r = !n.candidate || Object.keys(n.candidate).length === 0; if (r) for (var i = 1; i < t.length; i++)t[i].indexOf('\r\na=end-of-candidates\r\n') === -1 && (t[i] += 'a=end-of-candidates\r\n'); else n.candidate.candidate.indexOf('typ endOfCandidates') === -1 && (t[n.candidate.sdpMLineIndex + 1] += 'a=' + n.candidate.candidate + '\r\n'); if (e.localDescription.sdp = t.join(''), e.dispatchEvent(n), e.onicecandidate !== null && e.onicecandidate(n), !n.candidate && e.iceGatheringState !== 'complete') { var a = e.transceivers.every(function (e) { return e.iceGatherer && e.iceGatherer.state === 'completed' }); a && (e.iceGatheringState = 'complete') } }), this._localIceCandidatesBuffer = [] }, window.RTCPeerConnection.prototype.getConfiguration = function () { return this._config }, window.RTCPeerConnection.prototype.addStream = function (e) { var t = e.clone(); e.getTracks().forEach(function (e, n) { var r = t.getTracks()[n]; e.addEventListener('enabled', function (e) { r.enabled = e.enabled }) }), this.localStreams.push(t), this._maybeFireNegotiationNeeded() }, window.RTCPeerConnection.prototype.removeStream = function (e) { var t = this.localStreams.indexOf(e); t > -1 && (this.localStreams.splice(t, 1), this._maybeFireNegotiationNeeded()) }, window.RTCPeerConnection.prototype.getSenders = function () { return this.transceivers.filter(function (e) { return !!e.rtpSender }).map(function (e) { return e.rtpSender }) }, window.RTCPeerConnection.prototype.getReceivers = function () { return this.transceivers.filter(function (e) { return !!e.rtpReceiver }).map(function (e) { return e.rtpReceiver }) }, window.RTCPeerConnection.prototype._getCommonCapabilities = function (e, t) { var n = {codecs: [], headerExtensions: [], fecMechanisms: []}; return e.codecs.forEach(function (e) { for (var r = 0; r < t.codecs.length; r++) { var i = t.codecs[r]; if (e.name.toLowerCase() === i.name.toLowerCase() && e.clockRate === i.clockRate) { i.numChannels = Math.min(e.numChannels, i.numChannels), n.codecs.push(i), i.rtcpFeedback = i.rtcpFeedback.filter(function (t) { for (var n = 0; n < e.rtcpFeedback.length; n++) if (e.rtcpFeedback[n].type === t.type && e.rtcpFeedback[n].parameter === t.parameter) return !0; return !1 }); break } } }), e.headerExtensions.forEach(function (e) { for (var r = 0; r < t.headerExtensions.length; r++) { var i = t.headerExtensions[r]; if (e.uri === i.uri) { n.headerExtensions.push(i); break } } }), n }, window.RTCPeerConnection.prototype._createIceAndDtlsTransports = function (e, t) { var n = this, i = new RTCIceGatherer(n.iceOptions), a = new RTCIceTransport(i); i.onlocalcandidate = function (o) { var s = new Event('icecandidate'); s.candidate = {sdpMid: e, sdpMLineIndex: t}; var c = o.candidate, d = !c || Object.keys(c).length === 0; d ? (void 0 === i.state && (i.state = 'completed'), s.candidate.candidate = 'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates') : (c.component = a.component === 'RTCP' ? 2 : 1, s.candidate.candidate = r.writeCandidate(c)); var p = r.splitSections(n.localDescription.sdp); s.candidate.candidate.indexOf('typ endOfCandidates') === -1 ? p[s.candidate.sdpMLineIndex + 1] += 'a=' + s.candidate.candidate + '\r\n' : p[s.candidate.sdpMLineIndex + 1] += 'a=end-of-candidates\r\n', n.localDescription.sdp = p.join(''); var u = n.transceivers.every(function (e) { return e.iceGatherer && e.iceGatherer.state === 'completed' }); switch (n.iceGatheringState) { case 'new':n._localIceCandidatesBuffer.push(s), d && u && n._localIceCandidatesBuffer.push(new Event('icecandidate')); break; case 'gathering':n._emitBufferedCandidates(), n.dispatchEvent(s), n.onicecandidate !== null && n.onicecandidate(s), u && (n.dispatchEvent(new Event('icecandidate')), n.onicecandidate !== null && n.onicecandidate(new Event('icecandidate')), n.iceGatheringState = 'complete'); break; case 'complete': } }, a.onicestatechange = function () { n._updateConnectionState() }; var o = new RTCDtlsTransport(a); return o.ondtlsstatechange = function () { n._updateConnectionState() }, o.onerror = function () { o.state = 'failed', n._updateConnectionState() }, {iceGatherer: i, iceTransport: a, dtlsTransport: o} }, window.RTCPeerConnection.prototype._transceive = function (e, t, n) { var i = this._getCommonCapabilities(e.localCapabilities, e.remoteCapabilities); t && e.rtpSender && (i.encodings = e.sendEncodingParameters, i.rtcp = {cname: r.localCName}, e.recvEncodingParameters.length && (i.rtcp.ssrc = e.recvEncodingParameters[0].ssrc), e.rtpSender.send(i)), n && e.rtpReceiver && (e.kind === 'video' && e.recvEncodingParameters && e.recvEncodingParameters.forEach(function (e) { delete e.rtx }), i.encodings = e.recvEncodingParameters, i.rtcp = {cname: e.cname}, e.sendEncodingParameters.length && (i.rtcp.ssrc = e.sendEncodingParameters[0].ssrc), e.rtpReceiver.receive(i)) }, window.RTCPeerConnection.prototype.setLocalDescription = function (e) { var t, n, i = this; if (e.type === 'offer') this._pendingOffer && (t = r.splitSections(e.sdp), n = t.shift(), t.forEach(function (e, t) { var n = r.parseRtpParameters(e); i._pendingOffer[t].localCapabilities = n }), this.transceivers = this._pendingOffer, delete this._pendingOffer); else if (e.type === 'answer') { t = r.splitSections(i.remoteDescription.sdp), n = t.shift(); var a = r.matchPrefix(n, 'a=ice-lite').length > 0; t.forEach(function (e, t) { var o = i.transceivers[t], s = o.iceGatherer, c = o.iceTransport, d = o.dtlsTransport, p = o.localCapabilities, u = o.remoteCapabilities, f = e.split('\n', 1)[0].split(' ', 2)[1] === '0'; if (!f && !o.isDatachannel) { var l = r.getIceParameters(e, n); if (a) { var m = r.matchPrefix(e, 'a=candidate:').map(function (e) { return r.parseCandidate(e) }).filter(function (e) { return e.component === '1' }); m.length && c.setRemoteCandidates(m) } var h = r.getDtlsParameters(e, n); a && (h.role = 'server'), i.usingBundle && t !== 0 || (c.start(s, l, a ? 'controlling' : 'controlled'), d.start(h)); var v = i._getCommonCapabilities(p, u); i._transceive(o, v.codecs.length > 0, !1) } }) } switch (this.localDescription = {type: e.type, sdp: e.sdp}, e.type) { case 'offer':this._updateSignalingState('have-local-offer'); break; case 'answer':this._updateSignalingState('stable'); break; default:throw new TypeError('unsupported type "' + e.type + '"') } var o = arguments.length > 1 && typeof arguments[1] === 'function'; if (o) { var s = arguments[1]; window.setTimeout(function () { s(), i.iceGatheringState === 'new' && (i.iceGatheringState = 'gathering'), i._emitBufferedCandidates() }, 0) } var c = Promise.resolve(); return c.then(function () { o || (i.iceGatheringState === 'new' && (i.iceGatheringState = 'gathering'), window.setTimeout(i._emitBufferedCandidates.bind(i), 500)) }), c }, window.RTCPeerConnection.prototype.setRemoteDescription = function (e) { var t = this, n = new MediaStream(), i = [], a = r.splitSections(e.sdp), o = a.shift(), s = r.matchPrefix(o, 'a=ice-lite').length > 0; switch (this.usingBundle = r.matchPrefix(o, 'a=group:BUNDLE ').length > 0, a.forEach(function (a, c) { var d = r.splitLines(a), p = d[0].substr(2).split(' '), u = p[0], f = p[1] === '0', l = r.getDirection(a, o), m = r.matchPrefix(a, 'a=mid:'); if (m = m.length ? m[0].substr(6) : r.generateIdentifier(), u === 'application' && p[2] === 'DTLS/SCTP') return void (t.transceivers[c] = {mid: m, isDatachannel: !0}); var h, v, g, w, C, y, b, T, P, E, S, R, k = r.parseRtpParameters(a); f || (S = r.getIceParameters(a, o), R = r.getDtlsParameters(a, o), R.role = 'client'), T = r.parseRtpEncodingParameters(a); var x, D = r.matchPrefix(a, 'a=ssrc:').map(function (e) { return r.parseSsrcMedia(e) }).filter(function (e) { return e.attribute === 'cname' })[0]; D && (x = D.value); var O = r.matchPrefix(a, 'a=end-of-candidates', o).length > 0, M = r.matchPrefix(a, 'a=candidate:').map(function (e) { return r.parseCandidate(e) }).filter(function (e) { return e.component === '1' }); if (e.type !== 'offer' || f)e.type !== 'answer' || f || (h = t.transceivers[c], v = h.iceGatherer, g = h.iceTransport, w = h.dtlsTransport, C = h.rtpSender, y = h.rtpReceiver, b = h.sendEncodingParameters, P = h.localCapabilities, t.transceivers[c].recvEncodingParameters = T, t.transceivers[c].remoteCapabilities = k, t.transceivers[c].cname = x, (s || O) && M.length && g.setRemoteCandidates(M), t.usingBundle && c !== 0 || (g.start(v, S, 'controlling'), w.start(R)), t._transceive(h, l === 'sendrecv' || l === 'recvonly', l === 'sendrecv' || l === 'sendonly'), !y || l !== 'sendrecv' && l !== 'sendonly' ? delete h.rtpReceiver : (E = y.track, i.push([E, y]), n.addTrack(E))); else { var L = t.usingBundle && c > 0 ? {iceGatherer: t.transceivers[0].iceGatherer, iceTransport: t.transceivers[0].iceTransport, dtlsTransport: t.transceivers[0].dtlsTransport} : t._createIceAndDtlsTransports(m, c); if (O && L.iceTransport.setRemoteCandidates(M), P = RTCRtpReceiver.getCapabilities(u), P.codecs = P.codecs.filter(function (e) { return e.name !== 'rtx' }), b = [{ssrc: 1001 * (2 * c + 2)}], y = new RTCRtpReceiver(L.dtlsTransport, u), E = y.track, i.push([E, y]), n.addTrack(E), t.localStreams.length > 0 && t.localStreams[0].getTracks().length >= c) { var j; u === 'audio' ? j = t.localStreams[0].getAudioTracks()[0] : u === 'video' && (j = t.localStreams[0].getVideoTracks()[0]), j && (C = new RTCRtpSender(j, L.dtlsTransport)) }t.transceivers[c] = {iceGatherer: L.iceGatherer, iceTransport: L.iceTransport, dtlsTransport: L.dtlsTransport, localCapabilities: P, remoteCapabilities: k, rtpSender: C, rtpReceiver: y, kind: u, mid: m, cname: x, sendEncodingParameters: b, recvEncodingParameters: T}, t._transceive(t.transceivers[c], !1, l === 'sendrecv' || l === 'sendonly') } }), this.remoteDescription = {type: e.type, sdp: e.sdp}, e.type) { case 'offer':this._updateSignalingState('have-remote-offer'); break; case 'answer':this._updateSignalingState('stable'); break; default:throw new TypeError('unsupported type "' + e.type + '"') } return n.getTracks().length && (t.remoteStreams.push(n), window.setTimeout(function () { var e = new Event('addstream'); e.stream = n, t.dispatchEvent(e), t.onaddstream !== null && window.setTimeout(function () { t.onaddstream(e) }, 0), i.forEach(function (r) { var i = r[0], a = r[1], o = new Event('track'); o.track = i, o.receiver = a, o.streams = [n], t.dispatchEvent(e), t.ontrack !== null && window.setTimeout(function () { t.ontrack(o) }, 0) }) }, 0)), arguments.length > 1 && typeof arguments[1] === 'function' && window.setTimeout(arguments[1], 0), Promise.resolve() }, window.RTCPeerConnection.prototype.close = function () { this.transceivers.forEach(function (e) { e.iceTransport && e.iceTransport.stop(), e.dtlsTransport && e.dtlsTransport.stop(), e.rtpSender && e.rtpSender.stop(), e.rtpReceiver && e.rtpReceiver.stop() }), this._updateSignalingState('closed') }, window.RTCPeerConnection.prototype._updateSignalingState = function (e) { this.signalingState = e; var t = new Event('signalingstatechange'); this.dispatchEvent(t), this.onsignalingstatechange !== null && this.onsignalingstatechange(t) }, window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function () { var e = new Event('negotiationneeded'); this.dispatchEvent(e), this.onnegotiationneeded !== null && this.onnegotiationneeded(e) }, window.RTCPeerConnection.prototype._updateConnectionState = function () { var e, t = this, n = {new: 0, closed: 0, connecting: 0, checking: 0, connected: 0, completed: 0, failed: 0}; if (this.transceivers.forEach(function (e) { n[e.iceTransport.state]++, n[e.dtlsTransport.state]++ }), n.connected += n.completed, e = 'new', n.failed > 0 ? e = 'failed' : n.connecting > 0 || n.checking > 0 ? e = 'connecting' : n.disconnected > 0 ? e = 'disconnected' : n.new > 0 ? e = 'new' : (n.connected > 0 || n.completed > 0) && (e = 'connected'), e !== t.iceConnectionState) { t.iceConnectionState = e; var r = new Event('iceconnectionstatechange'); this.dispatchEvent(r), this.oniceconnectionstatechange !== null && this.oniceconnectionstatechange(r) } }, window.RTCPeerConnection.prototype.createOffer = function () {
          var e = this; if (this._pendingOffer) throw new Error('createOffer called while there is a pending offer.'); var t; arguments.length === 1 && typeof arguments[0] !== 'function' ? t = arguments[0] : arguments.length === 3 && (t = arguments[2]); var n = [], i = 0, a = 0; if (this.localStreams.length && (i = this.localStreams[0].getAudioTracks().length, a = this.localStreams[0].getVideoTracks().length),
t) { if (t.mandatory || t.optional) throw new TypeError('Legacy mandatory/optional constraints not supported.'); void 0 !== t.offerToReceiveAudio && (i = t.offerToReceiveAudio), void 0 !== t.offerToReceiveVideo && (a = t.offerToReceiveVideo) } for (this.localStreams.length && this.localStreams[0].getTracks().forEach(function (e) { n.push({kind: e.kind, track: e, wantReceive: e.kind === 'audio' ? i > 0 : a > 0}), e.kind === 'audio' ? i-- : e.kind === 'video' && a-- }); i > 0 || a > 0;)i > 0 && (n.push({kind: 'audio', wantReceive: !0}), i--), a > 0 && (n.push({kind: 'video', wantReceive: !0}), a--); var o = r.writeSessionBoilerplate(), s = []; n.forEach(function (t, n) { var i = t.track, a = t.kind, o = r.generateIdentifier(), c = e.usingBundle && n > 0 ? {iceGatherer: s[0].iceGatherer, iceTransport: s[0].iceTransport, dtlsTransport: s[0].dtlsTransport} : e._createIceAndDtlsTransports(o, n), d = RTCRtpSender.getCapabilities(a); d.codecs = d.codecs.filter(function (e) { return e.name !== 'rtx' }), d.codecs.forEach(function (e) { e.name === 'H264' && void 0 === e.parameters['level-asymmetry-allowed'] && (e.parameters['level-asymmetry-allowed'] = '1') }); var p, u, f = [{ssrc: 1001 * (2 * n + 1)}]; i && (p = new RTCRtpSender(i, c.dtlsTransport)), t.wantReceive && (u = new RTCRtpReceiver(c.dtlsTransport, a)), s[n] = {iceGatherer: c.iceGatherer, iceTransport: c.iceTransport, dtlsTransport: c.dtlsTransport, localCapabilities: d, remoteCapabilities: null, rtpSender: p, rtpReceiver: u, kind: a, mid: o, sendEncodingParameters: f, recvEncodingParameters: null} }), this.usingBundle && (o += 'a=group:BUNDLE ' + s.map(function (e) { return e.mid }).join(' ') + '\r\n'), n.forEach(function (t, n) { var i = s[n]; o += r.writeMediaSection(i, i.localCapabilities, 'offer', e.localStreams[0]) }), this._pendingOffer = s; var c = new RTCSessionDescription({type: 'offer', sdp: o}); return arguments.length && typeof arguments[0] === 'function' && window.setTimeout(arguments[0], 0, c), Promise.resolve(c)
        }, window.RTCPeerConnection.prototype.createAnswer = function () { var e = this, t = r.writeSessionBoilerplate(); this.usingBundle && (t += 'a=group:BUNDLE ' + this.transceivers.map(function (e) { return e.mid }).join(' ') + '\r\n'), this.transceivers.forEach(function (n) { if (n.isDatachannel) return void (t += 'm=application 0 DTLS/SCTP 5000\r\nc=IN IP4 0.0.0.0\r\na=mid:' + n.mid + '\r\n'); var i = e._getCommonCapabilities(n.localCapabilities, n.remoteCapabilities); t += r.writeMediaSection(n, i, 'answer', e.localStreams[0]) }); var n = new RTCSessionDescription({type: 'answer', sdp: t}); return arguments.length && typeof arguments[0] === 'function' && window.setTimeout(arguments[0], 0, n), Promise.resolve(n) }, window.RTCPeerConnection.prototype.addIceCandidate = function (e) { if (e) { var t = e.sdpMLineIndex; if (e.sdpMid) for (var n = 0; n < this.transceivers.length; n++) if (this.transceivers[n].mid === e.sdpMid) { t = n; break } var i = this.transceivers[t]; if (i) { var a = Object.keys(e.candidate).length > 0 ? r.parseCandidate(e.candidate) : {}; if (a.protocol === 'tcp' && (a.port === 0 || a.port === 9)) return; if (a.component !== '1') return; a.type === 'endOfCandidates' && (a = {}), i.iceTransport.addRemoteCandidate(a); var o = r.splitSections(this.remoteDescription.sdp); o[t + 1] += (a.type ? e.candidate.trim() : 'a=end-of-candidates') + '\r\n', this.remoteDescription.sdp = o.join('') } } else this.transceivers.forEach(function (e) { e.iceTransport.addRemoteCandidate({}) }); return arguments.length > 1 && typeof arguments[1] === 'function' && window.setTimeout(arguments[1], 0), Promise.resolve() }, window.RTCPeerConnection.prototype.getStats = function () { var e = []; this.transceivers.forEach(function (t) { ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function (n) { t[n] && e.push(t[n].getStats()) }) }); var t = arguments.length > 1 && typeof arguments[1] === 'function' && arguments[1]; return new Promise(function (n) { var r = new Map(); Promise.all(e).then(function (e) { e.forEach(function (e) { Object.keys(e).forEach(function (t) { r.set(t, e[t]), r[t] = e[t] }) }), t && window.setTimeout(t, 0, r), n(r) }) }) }
      }}; t.exports = {shimPeerConnection: a.shimPeerConnection, shimGetUserMedia: e('./getusermedia')}
  }, {'../utils': 11, './getusermedia': 7, sdp: 2}], 7: [function (e, t, n) { 'use strict'; t.exports = function () { var e = function (e) { return {name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name, message: e.message, constraint: e.constraint, toString: function () { return this.name }} }, t = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function (n) { return t(n).catch(function (t) { return Promise.reject(e(t)) }) } } }, {}], 8: [function (e, t, n) { 'use strict'; var r = e('../utils').browserDetails, i = {shimOnTrack: function () { typeof window !== 'object' || !window.RTCPeerConnection || 'ontrack' in window.RTCPeerConnection.prototype || Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {get: function () { return this._ontrack }, set: function (e) { this._ontrack && (this.removeEventListener('track', this._ontrack), this.removeEventListener('addstream', this._ontrackpoly)), this.addEventListener('track', this._ontrack = e), this.addEventListener('addstream', this._ontrackpoly = function (e) { e.stream.getTracks().forEach(function (t) { var n = new Event('track'); n.track = t, n.receiver = {track: t}, n.streams = [e.stream], this.dispatchEvent(n) }.bind(this)) }.bind(this)) }}) }, shimSourceObject: function () { typeof window === 'object' && (!window.HTMLMediaElement || 'srcObject' in window.HTMLMediaElement.prototype || Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {get: function () { return this.mozSrcObject }, set: function (e) { this.mozSrcObject = e }})) }, shimPeerConnection: function () { if (typeof window === 'object' && (window.RTCPeerConnection || window.mozRTCPeerConnection)) { window.RTCPeerConnection || (window.RTCPeerConnection = function (e, t) { if (r.version < 38 && e && e.iceServers) { for (var n = [], i = 0; i < e.iceServers.length; i++) { var a = e.iceServers[i]; if (a.hasOwnProperty('urls')) for (var o = 0; o < a.urls.length; o++) { var s = {url: a.urls[o]}; a.urls[o].indexOf('turn') === 0 && (s.username = a.username, s.credential = a.credential), n.push(s) } else n.push(e.iceServers[i]) }e.iceServers = n } return new mozRTCPeerConnection(e, t) }, window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype, mozRTCPeerConnection.generateCertificate && Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {get: function () { return mozRTCPeerConnection.generateCertificate }}), window.RTCSessionDescription = mozRTCSessionDescription, window.RTCIceCandidate = mozRTCIceCandidate), ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (e) { var t = RTCPeerConnection.prototype[e]; RTCPeerConnection.prototype[e] = function () { return arguments[0] = new (e === 'addIceCandidate' ? RTCIceCandidate : RTCSessionDescription)(arguments[0]), t.apply(this, arguments) } }); var e = RTCPeerConnection.prototype.addIceCandidate; if (RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? e.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }, r.version < 48) { var t = function (e) { var t = new Map(); return Object.keys(e).forEach(function (n) { t.set(n, e[n]), t[n] = e[n] }), t }, n = RTCPeerConnection.prototype.getStats; RTCPeerConnection.prototype.getStats = function (e, r, i) { return n.apply(this, [e || null]).then(function (e) { return t(e) }).then(r, i) } } } }}; t.exports = {shimOnTrack: i.shimOnTrack, shimSourceObject: i.shimSourceObject, shimPeerConnection: i.shimPeerConnection, shimGetUserMedia: e('./getusermedia')} }, {'../utils': 11, './getusermedia': 9}], 9: [function (e, t, n) { 'use strict'; var r = e('../utils').log, i = e('../utils').browserDetails; t.exports = function () { var e = function (e) { return {name: {SecurityError: 'NotAllowedError', PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name, message: {'The operation is insecure.': 'The request is not allowed by the user agent or the platform in the current context.'}[e.message] || e.message, constraint: e.constraint, toString: function () { return this.name + (this.message && ': ') + this.message }} }, t = function (t, n, a) { var o = function (e) { if (typeof e !== 'object' || e.require) return e; var t = []; return Object.keys(e).forEach(function (n) { if (n !== 'require' && n !== 'advanced' && n !== 'mediaSource') { var r = e[n] = typeof e[n] === 'object' ? e[n] : {ideal: e[n]}; if (void 0 === r.min && void 0 === r.max && void 0 === r.exact || t.push(n), void 0 !== r.exact && (typeof r.exact === 'number' ? r.min = r.max = r.exact : e[n] = r.exact, delete r.exact), void 0 !== r.ideal) { e.advanced = e.advanced || []; var i = {}; typeof r.ideal === 'number' ? i[n] = {min: r.ideal, max: r.ideal} : i[n] = r.ideal, e.advanced.push(i), delete r.ideal, Object.keys(r).length || delete e[n] } } }), t.length && (e.require = t), e }; return t = JSON.parse(JSON.stringify(t)), i.version < 38 && (r('spec: ' + JSON.stringify(t)), t.audio && (t.audio = o(t.audio)), t.video && (t.video = o(t.video)), r('ff37: ' + JSON.stringify(t))), navigator.mozGetUserMedia(t, n, function (t) { a(e(t)) }) }, n = function (e) { return new Promise(function (n, r) { t(e, n, r) }) }; if (navigator.mediaDevices || (navigator.mediaDevices = {getUserMedia: n, addEventListener: function () {}, removeEventListener: function () {}}), navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function () { return new Promise(function (e) { var t = [{kind: 'audioinput', deviceId: 'default', label: '', groupId: ''}, {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}]; e(t) }) }, i.version < 41) { var a = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices); navigator.mediaDevices.enumerateDevices = function () { return a().then(void 0, function (e) { if (e.name === 'NotFoundError') return []; throw e }) } } if (i.version < 49) { var o = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices); navigator.mediaDevices.getUserMedia = function (t) { return o(t).then(function (e) { if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(function (e) { e.stop() }), new DOMException('The object can not be found here.', 'NotFoundError'); return e }, function (t) { return Promise.reject(e(t)) }) } }navigator.getUserMedia = function (e, n, r) { return i.version < 44 ? t(e, n, r) : (console.warn('navigator.getUserMedia has been replaced by navigator.mediaDevices.getUserMedia'), void navigator.mediaDevices.getUserMedia(e).then(n, r)) } } }, {'../utils': 11}], 10: [function (e, t, n) { 'use strict'; var r = {shimGetUserMedia: function () { navigator.getUserMedia = navigator.webkitGetUserMedia }}; t.exports = {shimGetUserMedia: r.shimGetUserMedia} }, {}], 11: [function (e, t, n) { 'use strict'; var r = !0, i = {disableLog: function (e) { return typeof e !== 'boolean' ? new Error('Argument type: ' + typeof e + '. Please use a boolean.') : (r = e, e ? 'adapter.js logging disabled' : 'adapter.js logging enabled') }, log: function () { if (typeof window === 'object') { if (r) return; typeof console !== 'undefined' && typeof console.log === 'function' && console.log.apply(console, arguments) } }, extractVersion: function (e, t, n) { var r = e.match(t); return r && r.length >= n && parseInt(r[n], 10) }, detectBrowser: function () { var e = {}; if (e.browser = null, e.version = null, typeof window === 'undefined' || !window.navigator) return e.browser = 'Not a browser.', e; if (navigator.mozGetUserMedia)e.browser = 'firefox', e.version = this.extractVersion(navigator.userAgent, /Firefox\/([0-9]+)\./, 1); else if (navigator.webkitGetUserMedia) if (window.webkitRTCPeerConnection)e.browser = 'chrome', e.version = this.extractVersion(navigator.userAgent, /Chrom(e|ium)\/([0-9]+)\./, 2); else { if (!navigator.userAgent.match(/Version\/(\d+).(\d+)/)) return e.browser = 'Unsupported webkit-based browser with GUM support but no WebRTC support.', e; e.browser = 'safari', e.version = this.extractVersion(navigator.userAgent, /AppleWebKit\/([0-9]+)\./, 1) } else { if (!navigator.mediaDevices || !navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) return e.browser = 'Not a supported browser.', e; e.browser = 'edge', e.version = this.extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2) } return e }}; t.exports = {log: i.log, disableLog: i.disableLog, browserDetails: i.detectBrowser(), extractVersion: i.extractVersion} }, {}]}, {}, [1]))(1)
}))
